/*
 * Copyright (C) 2025 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

@!namespace("@ohos.multimedia.avsession", "avSession")

from ohos.multimodalInput.keyEvent use KeyEvent;
from ohos.multimedia.avCastPickerParam use AVCastPickerState;
from ohos.multimedia.avCastPickerParam use AVCastPickerStyle;

@!sts_inject("""
static { loadLibrary("avsession_taihe.z"); }
""")

@!sts_inject_into_module("import * as ohos_multimodalInput_keyEvent from './@ohos.multimodalInput.keyEvent';")
@!sts_inject_into_module("import * as ohos_multimedia_avCastPickerParam from './@ohos.multimedia.avCastPickerParam';")

enum CallState: i32 {
  CALL_STATE_IDLE = 0,
  CALL_STATE_INCOMING = 1,
  CALL_STATE_ACTIVE = 2,
  CALL_STATE_DIALING = 3,
  CALL_STATE_WAITING = 4,
  CALL_STATE_HOLDING = 5,
  CALL_STATE_DISCONNECTING = 6,
}

enum AVCastCategory: i32 {
  CATEGORY_LOCAL = 0,
  CATEGORY_REMOTE = 1,
}

struct AVCallState {
  state: CallState;
  muted: bool;
}

enum LoopMode: i32 {
  LOOP_MODE_SEQUENCE = 0,
  LOOP_MODE_SINGLE = 1,
  LOOP_MODE_LIST = 2,
  LOOP_MODE_SHUFFLE = 3,
  LOOP_MODE_CUSTOM = 4,
}

enum ResolutionLevel : i32 {
  RESOLUTION_480P = 0,
  RESOLUTION_720P = 1,
  RESOLUTION_1080P = 2,
  RESOLUTION_2K = 3,
  RESOLUTION_4K = 4,
}

enum DecoderType : String {
  OH_AVCODEC_MIMETYPE_VIDEO_AVC = "video/avc",
  OH_AVCODEC_MIMETYPE_VIDEO_HEVC = "video/hevc",
  OH_AVCODEC_MIMETYPE_AUDIO_VIVID = "audio/av3a",
}

enum DisplayTag : i32 {
  TAG_AUDIO_VIVID = 1,
}

union AVCastParameterType {
  typeDouble: f64;
  typeString: String;
  typeLoopMode: LoopMode;
  typePlaybackSpeed: @sts_type("media.PlaybackSpeed") Opaque;
}

struct AVCastControlCommand {
  command: String;
  parameter: Optional<AVCastParameterType>;
}

union AVImageType {
  typeString: String;
  typePixelMap: @sts_type("image.PixelMap") Opaque;
}

struct AVMediaDescription {
  assetId: String;
  title: Optional<String>;
  subtitle: Optional<String>;
  description: Optional<String>;
  mediaImage: Optional<AVImageType>;
  extras: Optional<@sts_type("Record<String, Object>") Opaque>;
  mediaType: Optional<String>;
  mediaSize: Optional<i32>;
  albumTitle: Optional<String>;
  albumCoverUri: Optional<String>;
  lyricContent: Optional<String>;
  lyricUri: Optional<String>;
  artist: Optional<String>;
  mediaUri: Optional<String>;
  fdSrc: Optional<@sts_type("media.AVFileDescriptor") Opaque>;
  dataSrc: Optional<@sts_type("media.AVDataSrcDescriptor") Opaque>;
  pcmSrc: Optional<bool>;
  drmScheme: Optional<String>;
  duration: Optional<i32>;
  startPosition: Optional<i32>;
  creditsPosition: Optional<i32>;
  appName: Optional<String>;
  displayTags: Optional<i32>;
  launchClientData: Optional<String>;
}

struct AVQueueItem {
  itemId: i32;
  description: Optional<AVMediaDescription>;
}

struct AudioCapabilities {
  @readonly streamInfos: Array<@sts_type("audio.AudioStreamInfo") Opaque>;
}

interface AVCastController {
  @gen_async("setDisplaySurface")
  @gen_promise("setDisplaySurface")
  SetDisplaySurfaceSync(surfaceId: String): void;

  @gen_promise("getSupportedDecoders")
  GetSupportedDecodersSync(): Array<DecoderType>;

  @gen_promise("getRecommendedResolutionLevel")
  GetRecommendedResolutionLevelSync(decoderType: DecoderType): ResolutionLevel;

  @gen_promise("getSupportedHdrCapabilities")
  GetSupportedHdrCapabilitiesSync(): Array<@sts_type("hdrCapability.HDRFormat") Opaque>;

  @gen_promise("getSupportedPlaySpeeds")
  GetSupportedPlaySpeedsSync(): Array<f64>;

  @gen_async("sendControlCommand")
  @gen_promise("sendControlCommand")
  SendControlCommandSync(command: AVCastControlCommand): void;

  @gen_async("start")
  @gen_promise("start")
  StartSync(item: AVQueueItem): void;

  @gen_async("prepare")
  @gen_promise("prepare")
  PrepareSync(item: AVQueueItem): void;

  @gen_async("getCurrentItem")
  @gen_promise("getCurrentItem")
  GetCurrentItemSync(): AVQueueItem;

  @gen_promise("processMediaKeyResponse")
  ProcessMediaKeyResponseSync(assetId: String, response: @arraybuffer Array<u8>): void;

  @gen_async("release")
  @gen_promise("release")
  ReleaseSync(): void;

  @gen_async("getAVPlaybackState")
  @gen_promise("getAVPlaybackState")
  GetAVPlaybackStateSync(): AVPlaybackState;

  @gen_async("getValidCommands")
  @gen_promise("getValidCommands")
  GetValidCommandsSync(): Array<String>;

  @gen_promise("sendCustomData")
  SendCustomDataSync(data: @sts_type("Record<String, Object>") Opaque): void;

  OnPlaybackStateChange(filter: Array<String>, callback: (data: AVPlaybackState) => void): void;
  OnPlaybackStateChangeAll(callback: (data: AVPlaybackState) => void): void;
  OnMediaItemChange(callback: (data: AVQueueItem) => void): void;
  OnPlayNext(callback: () => void): void;
  OnPlayPrevious(callback: () => void): void;
  OnRequestPlay(callback: (data: AVQueueItem) => void): void;
  OnEndOfStream(callback: () => void): void;
  OnSeekDone(callback: (data: i32) => void): void;
  OnValidCommandChange(callback: (data: Array<String>) => void): void;
  OnVideoSizeChange(callback: (width: i32, height: i32) => void): void;
  OnError(callback: (err: @sts_type("BusinessError<void>") Opaque )=> void): void;
  OnCastControlGenericError(callback: (err: @sts_type("BusinessError<void>") Opaque )=> void): void;
  OnCastControlIoError(callback: (err: @sts_type("BusinessError<void>") Opaque )=> void): void;
  OnCastControlParsingError(callback: (err: @sts_type("BusinessError<void>") Opaque )=> void): void;
  OnCastControlDecodingError(callback: (err: @sts_type("BusinessError<void>") Opaque )=> void): void;
  OnCastControlAudioRendererError(callback: (err: @sts_type("BusinessError<void>") Opaque )=> void): void;
  OnCastControlDrmError(callback: (err: @sts_type("BusinessError<void>") Opaque )=> void): void;
  OnKeyRequest(callback: (assetId: String, requestData: @arraybuffer Array<u8>) => void): void;
  OnCustomDataChange(callback: (data: @sts_type("Record<String, Object>") Opaque) =>void): void;

  OffPlaybackStateChange(callback: Optional<(data: AVPlaybackState) => void>): void;
  OffMediaItemChange(callback: Optional<(data: AVQueueItem) => void>): void;
  OffPlayNext(callback: Optional<() => void>): void;
  OffPlayPrevious(callback: Optional<() => void>): void;
  OffRequestPlay(callback: Optional<(data: AVQueueItem) => void>): void;
  OffEndOfStream(callback: Optional<() => void>): void;
  OffSeekDone(callback: Optional<(data: i32) => void>): void;
  OffValidCommandChange(callback: Optional<(data: Array<String>) => void>): void;
  OffVideoSizeChange(callback: Optional<(width: i32, height: i32) => void>): void;
  OffError(callback: Optional<(err: @sts_type("BusinessError<void>") Opaque )=> void>): void;
  OffCastControlGenericError(callback: Optional<(err: @sts_type("BusinessError<void>") Opaque )=> void>): void;
  OffCastControlIoError(callback: Optional<(err: @sts_type("BusinessError<void>") Opaque )=> void>): void;
  OffCastControlParsingError(callback: Optional<(err: @sts_type("BusinessError<void>") Opaque )=> void>): void;
  OffCastControlDecodingError(callback: Optional<(err: @sts_type("BusinessError<void>") Opaque )=> void>): void;
  OffCastControlAudioRendererError(callback: Optional<(err: @sts_type("BusinessError<void>") Opaque )=> void>): void;
  OffCastControlDrmError(callback: Optional<(err: @sts_type("BusinessError<void>") Opaque )=> void>): void;
  OffKeyRequest(callback: Optional<(assetId: String, requestData: @arraybuffer Array<u8>) => void>): void;
  OffCustomDataChange(callback: Optional<(data: @sts_type("Record<String, Object>") Opaque) => void>): void;
}

enum SkipIntervals: i32 {
  SECONDS_10 = 10,
  SECONDS_15 = 15,
  SECONDS_30 = 30,
}

enum ProtocolType: i32 {
  TYPE_LOCAL = 0,
  TYPE_CAST_PLUS_MIRROR = 1,
  TYPE_CAST_PLUS_STREAM = 2,
  TYPE_DLNA = 4,
  TYPE_CAST_PLUS_AUDIO = 8,
}

struct AVMetadata {
  assetId: String;
  title: Optional<String>;
  artist: Optional<String>;
  author: Optional<String>;
  avQueueName: Optional<String>;
  avQueueId: Optional<String>;
  avQueueImage: Optional<AVImageType>;
  album: Optional<String>;
  writer: Optional<String>;
  composer: Optional<String>;
  duration: Optional<i64>;
  mediaImage: Optional<AVImageType>;
  @readonly bundleIcon: Optional<@sts_type("image.PixelMap") Opaque>;
  publishDate: Optional<@sts_type("Date") Opaque>;
  subtitle: Optional<String>;
  description: Optional<String>;
  lyric: Optional<String>;
  singleLyricText: Optional<String>;
  previousAssetId: Optional<String>;
  nextAssetId: Optional<String>;
  filter: Optional<i32>;
  drmSchemes: Optional<Array<String>>;
  skipIntervals: Optional<SkipIntervals>;
  displayTags: Optional<i32>;
}

enum PlaybackState: i32 {
  PLAYBACK_STATE_INITIAL = 0,
  PLAYBACK_STATE_PREPARE = 1,
  PLAYBACK_STATE_PLAY = 2,
  PLAYBACK_STATE_PAUSE = 3,
  PLAYBACK_STATE_FAST_FORWARD = 4,
  PLAYBACK_STATE_REWIND = 5,
  PLAYBACK_STATE_STOP = 6,
  PLAYBACK_STATE_COMPLETED = 7,
  PLAYBACK_STATE_RELEASED = 8,
  PLAYBACK_STATE_ERROR = 9,
  PLAYBACK_STATE_IDLE = 10,
  PLAYBACK_STATE_BUFFERING = 11,
}

struct PlaybackPosition {
  elapsedTime: i64;
  updateTime: i64;
}

struct AVPlaybackState {
  state: Optional<PlaybackState>;
  speed: Optional<f64>;
  position: Optional<PlaybackPosition>;
  bufferedTime: Optional<i64>;
  loopMode: Optional<LoopMode>;
  isFavorite: Optional<bool>;
  activeItemId: Optional<i32>;
  volume: Optional<i32>;
  maxVolume: Optional<i32>;
  muted: Optional<bool>;
  duration: Optional<i32>;
  videoWidth: Optional<i32>;
  videoHeight: Optional<i32>;
  extras: Optional<@sts_type("Record<String, Object>") Opaque>;
}

struct AVQueueInfo {
  bundleName: String;
  avQueueName: String;
  avQueueId: String;
  avQueueImage: AVImageType;
  lastPlayedTime: Optional<i64>;
}

enum DeviceType: i32 {
  DEVICE_TYPE_LOCAL = 0,
  DEVICE_TYPE_TV = 2,
  DEVICE_TYPE_SMART_SPEAKER = 3,
  DEVICE_TYPE_BLUETOOTH = 10,
}

struct DeviceInfo {
  castCategory: AVCastCategory;
  deviceId: String;
  deviceName: String;
  deviceType: DeviceType;
  manufacturer: Optional<String>;
  modelName: Optional<String>;
  networkId: Optional<String>;
  ipAddress: Optional<String>;
  providerId: Optional<i32>;
  supportedProtocols: Optional<i32>;
  supportedDrmCapabilities: Optional<Array<String>>;
  supportedPullClients: Optional<Array<u32>>;
  authenticationStatus: Optional<i32>;
  isLegacy: Optional<bool>;
  mediumTypes: Optional<i32>;
  audioCapabilities: Optional<AudioCapabilities>;
  remoteDeviceType: Optional<i32>;
}

struct CallMetadata {
  name: Optional<String>;
  phoneNumber: Optional<String>;
  avatar: Optional<@sts_type("image.PixelMap") Opaque>;
}

struct OutputDeviceInfo {
  devices: Array<DeviceInfo>;
}

union AVControlParameterType {
  typeDouble: f64;
  typeString: String;
  typeLoopMode: LoopMode;
}

struct AVControlCommand {
  command: String;
  parameter: Optional<AVControlParameterType>;
  commandInfo: Optional<CommandInfo>;
}

struct DesktopLyricState {
  isLocked: bool;
}

interface AVSession {
  @get GetSessionId(): String;
  @get GetSessionType(): String;
  @get GetSessionTag(): String;

  @gen_async("setAVMetadata")
  @gen_promise("setAVMetadata")
  SetAVMetadataSync(data: AVMetadata): void;

  @gen_async("setCallMetadata")
  @gen_promise("setCallMetadata")
  SetCallMetadataSync(data: CallMetadata): void;

  @gen_async("setAVPlaybackState")
  @gen_promise("setAVPlaybackState")
  SetAVPlaybackStateSync(state: AVPlaybackState): void;

  @gen_async("setAVCallState")
  @gen_promise("setAVCallState")
  SetAVCallStateSync(state: AVCallState): void;

  @gen_async("setLaunchAbility")
  @gen_promise("setLaunchAbility")
  SetLaunchAbilitySync(ability: @sts_type("WantAgent") Opaque): void;

  @gen_async("dispatchSessionEvent")
  @gen_promise("dispatchSessionEvent")
  DispatchSessionEventSync(event: String, args: @sts_type("Record<String, Object>") Opaque): void;

  @gen_async("setAVQueueItems")
  @gen_promise("setAVQueueItems")
  SetAVQueueItemsSync(items: Array<AVQueueItem>): void;

  @gen_async("setAVQueueTitle")
  @gen_promise("setAVQueueTitle")
  SetAVQueueTitleSync(title: String): void;

  @gen_async("setExtras")
  @gen_promise("setExtras")
  SetExtrasSync(extras: @sts_type("Record<String, Object>") Opaque): void;

  @gen_async("getController")
  @gen_promise("getController")
  GetControllerSync(): AVSessionController;

  @gen_async("getAVCastController")
  @gen_promise("getAVCastController")
  GetAVCastControllerSync(): Optional<AVCastController>;

  @gen_async("getOutputDevice")
  @gen_promise("getOutputDevice")
  GetOutputDeviceSync(): OutputDeviceInfo;

  @gen_promise("getAllCastDisplays")
  GetAllCastDisplaysSync(): Array<CastDisplayInfo>;

  @gen_async("stopCasting")
  @gen_promise("stopCasting")
  StopCastingSync(): void;

  @gen_async("activate")
  @gen_promise("activate")
  ActivateSync(): void;

  @gen_async("deactivate")
  @gen_promise("deactivate")
  DeactivateSync(): void;

  @gen_async("destroy")
  @gen_promise("destroy")
  DestroySync(): void;

  @gen_promise("sendCustomData")
  SendCustomDataSync(data: @sts_type("Record<String, Object>") Opaque): void;

  @gen_promise("enableDesktopLyric")
  EnableDesktopLyricSync(enable: bool): void;

  @gen_promise("setDesktopLyricVisible")
  SetDesktopLyricVisibleSync(visible: bool): void;

  @gen_promise("isDesktopLyricVisible")
  IsDesktopLyricVisibleSync(): bool;

  @gen_promise("setDesktopLyricState")
  SetDesktopLyricStateSync(state: DesktopLyricState): void;

  @gen_promise("getDesktopLyricState")
  GetDesktopLyricStateSync(): DesktopLyricState;

  OnPlay(callback: (commandInfo: CommandInfo) => void): void;
  OnPause(callback: () => void): void;
  OnStop(callback: () => void): void;
  OnPlayNext(callback: (commandInfo: CommandInfo) => void): void;
  OnPlayPrevious(callback: (commandInfo: CommandInfo) => void): void;
  OnFastForward(callback: (time: i64, commandInfo: CommandInfo) => void): void;
  OnRewind(callback: (time: i64, commandInfo: CommandInfo) => void): void;
  OnPlayWithAssetId(callback: (assetId: String) => void): void;
  OnSeek(callback: (time: i64) => void): void;
  OnSetSpeed(callback: (speed: f64) => void): void;
  OnSetLoopMode(callback: (loopMode: LoopMode) => void): void;
  OnSetTargetLoopMode(callback: (loopMode: LoopMode) => void): void;
  OnToggleFavorite(callback: (assetId: String) => void): void;
  OnHandleKeyEvent(callback: (event: @sts_type("ohos_multimodalInput_keyEvent.KeyEvent") Opaque) => void): void;
  OnOutputDeviceChange(callback: (state: ConnectionState, device: OutputDeviceInfo) => void): void;
  OnCommonCommand(callback: (command: String, args: @sts_type("Record<String, Object>") Opaque) => void): void;
  OnSkipToQueueItem(callback: (itemId: i32) => void): void;
  OnAnswer(callback: () => void): void;
  OnHangUp(callback: () => void): void;
  OnToggleCallMute(callback: () => void): void;
  OnCastDisplayChange(callback: (data: CastDisplayInfo) => void): void;
  OnCustomDataChange(callback: (data: @sts_type("Record<String, Object>") Opaque) =>void): void;
  OnDesktopLyricVisibilityChanged(callback: (visible: bool) => void): void;
  OnDesktopLyricStateChanged(callback: (state: DesktopLyricState) => void): void;

  OffPlay(callback: Optional<(commandInfo: CommandInfo) => void>): void;
  OffPause(callback: Optional<() => void>): void;
  OffStop(callback: Optional<() => void>): void;
  OffPlayNext(callback: Optional<(commandInfo: CommandInfo) => void>): void;
  OffPlayPrevious(callback: Optional<(commandInfo: CommandInfo) => void>): void;
  OffFastForward(callback: Optional<(time: i64, commandInfo: CommandInfo) => void>): void;
  OffRewind(callback: Optional<(time: i64, commandInfo: CommandInfo) => void>): void;
  OffPlayWithAssetId(callback: Optional<(assetId: String) => void>): void;
  OffSeek(callback: Optional<(time: i64) => void>): void;
  OffSetSpeed(callback: Optional<(speed: f64) => void>): void;
  OffSetLoopMode(callback: Optional<(loopMode: LoopMode) => void>): void;
  OffSetTargetLoopMode(callback: Optional<(loopMode: LoopMode) => void>): void;
  OffToggleFavorite(callback: Optional<(assetId: String) => void>): void;
  OffHandleKeyEvent(callback: Optional<(event: @sts_type("ohos_multimodalInput_keyEvent.KeyEvent") Opaque) => void>): void;
  OffOutputDeviceChange(callback: Optional<(state: ConnectionState, device: OutputDeviceInfo) => void>): void;
  OffCommonCommand(callback: Optional<(command: String, args: @sts_type("Record<String, Object>") Opaque) => void>): void;
  OffSkipToQueueItem(callback: Optional<(itemId: i32) => void>): void;
  OffAnswer(callback: Optional<() => void>): void;
  OffHangUp(callback: Optional<() => void>): void;
  OffToggleCallMute(callback: Optional<() => void>): void;
  OffCastDisplayChange(callback: Optional<(data: CastDisplayInfo) => void>): void;
  OffCustomDataChange(callback: Optional<(data: @sts_type("Record<String, Object>") Opaque) => void>): void;
  OffDesktopLyricVisibilityChanged(callback: Optional<(visible: bool) => void>): void;
  OffDesktopLyricStateChanged(callback: Optional<(state: DesktopLyricState) => void>): void;
}

interface AVSessionController {
  @get GetSessionId(): String;

  @gen_async("getAVPlaybackState")
  @gen_promise("getAVPlaybackState")
  GetAVPlaybackStateSync(): AVPlaybackState;

  @gen_async("getAVMetadata")
  @gen_promise("getAVMetadata")
  GetAVMetadataSync(): AVMetadata;

  @gen_async("getAVCallState")
  @gen_promise("getAVCallState")
  GetAVCallStateSync(): AVCallState;

  @gen_async("getCallMetadata")
  @gen_promise("getCallMetadata")
  GetCallMetadataSync(): CallMetadata;

  @gen_async("getAVQueueTitle")
  @gen_promise("getAVQueueTitle")
  GetAVQueueTitleSync(): String;

  @gen_async("getAVQueueItems")
  @gen_promise("getAVQueueItems")
  GetAVQueueItemsSync(): Array<AVQueueItem>;

  @gen_async("skipToQueueItem")
  @gen_promise("skipToQueueItem")
  SkipToQueueItemSync(itemId: i32): void;

  @gen_async("getOutputDevice")
  @gen_promise("getOutputDevice")
  GetOutputDeviceSync(): OutputDeviceInfo;

  @gen_async("sendAVKeyEvent")
  @gen_promise("sendAVKeyEvent")
  SendAVKeyEventSync(event: KeyEvent): void;

  @gen_async("getLaunchAbility")
  @gen_promise("getLaunchAbility")
  GetLaunchAbilitySync(): @sts_type("WantAgent") Opaque;

  GetRealPlaybackPositionSync(): i64;

  @gen_async("isActive")
  @gen_promise("isActive")
  IsActiveSync(): bool;

  @gen_async("destroy")
  @gen_promise("destroy")
  DestroySync(): void;

  @gen_async("getValidCommands")
  @gen_promise("getValidCommands")
  GetValidCommandsSync(): Array<String>;

  @gen_async("sendControlCommand")
  @gen_promise("sendControlCommand")
  SendControlCommandSync(command: AVControlCommand): void;

  @gen_async("sendCommonCommand")
  @gen_promise("sendCommonCommand")
  SendCommonCommandSync(command: String, args: @sts_type("Record<String, Object>") Opaque): void;

  @gen_async("getExtras")
  @gen_promise("getExtras")
  GetExtrasSync(): @sts_type("Record<String, Object>") Opaque;

  @gen_promise("getExtrasWithEvent")
  GetExtrasWithEventSync(extraEvent: String): @sts_type("Record<String, Object>") Opaque;

  @gen_promise("sendCustomData")
  SendCustomDataSync(data: @sts_type("Record<String, Object>") Opaque): void;

  @gen_promise("isDesktopLyricEnabled")
  IsDesktopLyricEnabledSync(): bool;

  @gen_promise("setDesktopLyricVisible")
  SetDesktopLyricVisibleSync(visible: bool): void;

  @gen_promise("isDesktopLyricVisible")
  IsDesktopLyricVisibleSync(): bool;

  @gen_promise("setDesktopLyricState")
  SetDesktopLyricStateSync(state: DesktopLyricState): void;

  @gen_promise("getDesktopLyricState")
  GetDesktopLyricStateSync(): DesktopLyricState;

  OnMetadataChange(filter: Array<String>, callback: (data: AVMetadata) => void): void;
  OnMetadataChangeAll(callback: (data: AVMetadata) => void): void;
  OnPlaybackStateChange(filter: Array<String>, callback: (data: AVPlaybackState) => void): void;
  OnPlaybackStateChangeAll(callback: (data: AVPlaybackState) => void): void;
  OnCallMetadataChange(filter: Array<String>, callback: (data: CallMetadata) => void): void;
  OnCallMetadataChangeAll(callback: (data: CallMetadata) => void): void;
  OnCallStateChange(filter: Array<String>, callback: (data: AVCallState) => void): void;
  OnCallStateChangeAll(callback: (data: AVCallState) => void): void;
  OnSessionDestroy(callback: () => void): void;
  OnActiveStateChange(callback: (data: bool) => void): void;
  OnValidCommandChange(callback: (data: Array<String>) => void): void;
  OnOutputDeviceChange(callback: (state: ConnectionState, device: OutputDeviceInfo) => void): void;
  OnSessionEvent(callback: (sessionEvent: String, args: @sts_type("Record<String, Object>") Opaque) => void): void;
  OnQueueItemsChange(callback: (data: Array<AVQueueItem>) => void): void;
  OnQueueTitleChange(callback: (data: String) => void): void;
  OnExtrasChange(callback: (data: @sts_type("Record<String, Object>") Opaque) => void): void;
  OnCustomDataChange(callback: (data: @sts_type("Record<String, Object>") Opaque) => void): void;
  OnDesktopLyricVisibilityChanged(callback: (data: bool) => void): void;
  OnDesktopLyricStateChanged(callback: (data: DesktopLyricState) => void): void;
  OnDesktopLyricEnabled(callback: (data: bool) => void): void;

  OffMetadataChange(callback: Optional<(data: AVMetadata) => void>): void;
  OffPlaybackStateChange(callback: Optional<(data: AVPlaybackState) => void>): void;
  OffCallMetadataChange(callback: Optional<(data: CallMetadata) => void>): void;
  OffCallStateChange(callback: Optional<(data: AVCallState) => void>): void;
  OffSessionDestroy(callback: Optional<() => void>): void;
  OffActiveStateChange(callback: Optional<(data: bool) => void>): void;
  OffValidCommandChange(callback: Optional<(data: Array<String>) => void>): void;
  OffOutputDeviceChange(callback: Optional<(state: ConnectionState, device: OutputDeviceInfo) => void>): void;
  OffSessionEvent(callback: Optional<(sessionEvent: String, args: @sts_type("Record<String, Object>") Opaque) => void>): void;
  OffQueueItemsChange(callback: Optional<(data: Array<AVQueueItem>) => void>): void;
  OffQueueTitleChange(callback: Optional<(data: String) => void>): void;
  OffExtrasChange(callback: Optional<(data: @sts_type("Record<String, Object>") Opaque) => void>): void;
  OffCustomDataChange(callback: Optional<(data: @sts_type("Record<String, Object>") Opaque) => void>): void;
  OffDesktopLyricVisibilityChanged(callback: Optional<(data: bool) => void>): void;
  OffDesktopLyricStateChanged(callback: Optional<(data: DesktopLyricState) => void>): void;
  OffDesktopLyricEnabled(callback: Optional<(data: bool) => void>): void;
}

struct AVSessionDescriptor {
  sessionId: String;
  type: String;
  sessionTag: String;
  elementName: @sts_type("ElementName") Opaque;
  isActive: bool;
  isTopSession: bool;
  outputDevice: OutputDeviceInfo;
}

enum CastDisplayState: i32 {
  STATE_OFF = 1,
  STATE_ON = 2,
}

struct CastDisplayInfo {
  id: i64;
  name: String;
  state: CastDisplayState;
  width: i32;
  height: i32;
}

enum ConnectionState: i32 {
  STATE_CONNECTING = 0,
  STATE_CONNECTED = 1,
  STATE_DISCONNECTED = 6,
}

struct SessionToken {
  sessionId: String;
  pid: Optional<i64>;
  uid: Optional<i64>;
}

struct AVCastPickerOptions {
  sessionType: Optional<String>;
  pickerStyle: Optional<AVCastPickerStyle>;
  menuPosition: Optional<MenuPosition>;
}

interface AVCastPickerHelperInner {
  @gen_promise("select")
  SelectSync(options: Optional<AVCastPickerOptions>): void;

  OnPickerStateChange(callback: (data: AVCastPickerState) => void): void;

  OffPickerStateChange(callback: Optional<(data: AVCastPickerState) => void>): void;

  @gen_promise("resetCommunicationDevice")
  ResetCommunicationDeviceSync(): void;
}

function CreateAVCastPickerHelperInnerSync(context: @sts_type("Context") Opaque): AVCastPickerHelperInner;

@!sts_inject("""
function businessError<T = void>(c: int, d?: string): BusinessError<T> {
  let err: BusinessError<T> = new BusinessError<T>();
  err.code = c;
  err.message = d ? d : "";
  return err;
}
class AVCastPickerHelper {
  private objectInner: AVCastPickerHelperInner | undefined = undefined;

  constructor(context: Context) {
    this.objectInner = createAVCastPickerHelperInnerSync(context);
  }

  select(options?: AVCastPickerOptions): Promise<void> | undefined {
    if (this.objectInner === undefined) {
      return new Promise<void>((resolve: (arg: undefined) => void, reject: (e: Error) => void): void => {
        let err: BusinessError<void> = businessError(-1, "AVCastPickerHelperInner is not initialized");
        reject(err);
      });
    }
    return this.objectInner?.select(options);
  }

  onPickerStateChange(callback: Callback<ohos_multimedia_avCastPickerParam.AVCastPickerState>) : void {
      this.objectInner?.onPickerStateChange(callback as ((data: ohos_multimedia_avCastPickerParam.AVCastPickerState) => void));
  }

  offPickerStateChange(callback?: Callback<ohos_multimedia_avCastPickerParam.AVCastPickerState>) : void {
      this.objectInner?.offPickerStateChange(callback as ((data: ohos_multimedia_avCastPickerParam.AVCastPickerState) => void) | undefined);
  }

  resetCommunicationDevice(): Promise<void> | undefined {
    if (this.objectInner === undefined) {
      return undefined;
    }
    return this.objectInner?.resetCommunicationDevice();
  }
}
""")

@gen_async("createAVSession")
@gen_promise("createAVSession")
function CreateAVSessionSync(context: @sts_type("Context") Opaque, tag: String, type: String): AVSession;

@gen_promise("getAVSession")
function GetAVSessionSync(context: @sts_type("Context") Opaque): AVSession;

@gen_async("getAllSessionDescriptors")
@gen_promise("getAllSessionDescriptors")
function GetAllSessionDescriptorsSync(): Array<AVSessionDescriptor>;

@gen_async("getHistoricalSessionDescriptors")
function GetHistoricalSessionDescriptorsSync(maxSize: i32): Array<AVSessionDescriptor>;

@gen_promise("getHistoricalSessionDescriptors")
function GetHistoricalSessionDescriptorsOptionalSync(maxSize: Optional<i32>): Array<AVSessionDescriptor>;

@gen_async("getHistoricalAVQueueInfos")
@gen_promise("getHistoricalAVQueueInfos")
function GetHistoricalAVQueueInfosSync(maxSize: i32, maxAppSize: i32): Array<AVQueueInfo>;

@gen_async("createController")
@gen_promise("createController")
function CreateControllerSync(sessionId: String): AVSessionController;

@gen_promise("startAVPlayback")
function StartAVPlaybackSync(bundleName: String, assetId: String): void;

@gen_promise("startAVPlayback")
function StartAVPlaybackInfoSync(bundleName: String, assetId: String, info: CommandInfo): void;

@gen_async("getAVCastController")
@gen_promise("getAVCastController")
function GetAVCastControllerSync(sessionId: String): Optional<AVCastController>;

@gen_async("startCasting")
@gen_promise("startCasting")
function StartCastingSync(session: SessionToken, device: OutputDeviceInfo): void;

@gen_async("stopCasting")
@gen_promise("stopCasting")
function StopCastingSync(session: SessionToken): void;

@gen_async("startCastDeviceDiscovery")
function StartCastDeviceDiscoverySync(): void;

@gen_async("startCastDeviceDiscovery")
function StartCastDeviceDiscoveryFilter(filter: i32): void;

@gen_promise("startCastDeviceDiscovery")
function StartCastDeviceDiscoveryFilterDrm(filter: Optional<i32>, drmSchemes: Optional<Array<String>>): void;

@gen_async("stopCastDeviceDiscovery")
@gen_promise("stopCastDeviceDiscovery")
function StopCastDeviceDiscoverySync(): void;

@gen_async("setDiscoverable")
@gen_promise("setDiscoverable")
function SetDiscoverableSync(enable: bool): void;

@gen_async("castAudioSession")
@gen_promise("castAudioSession")
function CastAudioSync(session: SessionToken, audioDevices: Array<@sts_type("audio.AudioDeviceDescriptor") Opaque>): void;

@gen_promise("castAudioSessionAll")
function CastAudioAllSync(audioDevices: Array<@sts_type("audio.AudioDeviceDescriptor") Opaque>): void;

@gen_promise("getDistributedSessionController")
function GetDistributedSessionControllerSync(distributedSessionType: DistributedSessionType): Array<AVSessionController>;

@gen_promise("isDesktopLyricSupported")
function IsDesktopLyricSupportedSync(): bool;

@gen_async("sendSystemAVKeyEvent")
@gen_promise("sendSystemAVKeyEvent")
function SendSystemAVKeyEventSync(event: KeyEvent): void;

@gen_async("sendSystemControlCommand")
@gen_promise("sendSystemControlCommand")
function SendSystemControlCommandSync(command: AVControlCommand): void;

@gen_promise("startDeviceLogging")
function StartDeviceLoggingSync(url: String, maxSize: Optional<i32>): void;

@gen_promise("stopDeviceLogging")
function StopDeviceLoggingSync(): void;

function CreateAVKeyEventSync(nativePtr: i64): KeyEvent;

@gen_promise("getSessionDescriptors")
function GetSessionDescriptorsSync(category: SessionCategory): Array<AVSessionDescriptor>;

enum DistributedSessionType :i32 {
  TYPE_SESSION_REMOTE = 0,
  TYPE_SESSION_MIGRATE_IN = 1,
  TYPE_SESSION_MIGRATE_OUT = 2,
}

enum DeviceLogEventCode :i32 {
  DEVICE_LOG_FULL = 1,
  DEVICE_LOG_EXCEPTION = 2,
}

struct DeviceState {
  @readonly deviceId: String;
  @readonly deviceState: i32;
  @readonly reasonCode: i32;
  @readonly radarErrorCode: i32;
}

function OnDistributedSessionChange(param: DistributedSessionType, callback: (data: Array<AVSessionController>) => void): void;
function OffDistributedSessionChange(param: DistributedSessionType, callback: Optional<(data: Array<AVSessionController>) => void>): void;
function OnSessionServiceDie(callback: () => void): void;
function OffSessionServiceDie(callback: Optional<() => void>): void;
function OnActiveSessionChanged(callback: (data: Array<AVSessionDescriptor>) => void): void;
function OffActiveSessionChanged(callback: Optional<(data: Array<AVSessionDescriptor>) => void>): void;

function OnSessionCreate(callback: (session: AVSessionDescriptor) => void): void;
function OnSessionDestroy(callback: (session: AVSessionDescriptor) => void): void;
function OnTopSessionChange(callback: (session: AVSessionDescriptor) => void): void;
function OnDeviceAvailable(callback: (device: OutputDeviceInfo) => void): void;
function OnDeviceLogEvent(callback: (eventCode: DeviceLogEventCode) => void): void;
function OnDeviceOffline(callback: (deviceId: String) => void): void;
function OnDeviceStateChanged(callback: (deviceState: DeviceState) => void): void;

function OffSessionCreate(callback: Optional<(session: AVSessionDescriptor) => void>): void;
function OffSessionDestroy(callback: Optional<(session: AVSessionDescriptor) => void>): void;
function OffTopSessionChange(callback: Optional<(session: AVSessionDescriptor) => void>): void;
function OffDeviceAvailable(callback: Optional<(device: OutputDeviceInfo) => void>): void;
function OffDeviceLogEvent(callback: Optional<(eventCode: DeviceLogEventCode) => void>): void;
function OffDeviceOffline(callback: Optional<(deviceId: String) => void>): void;
function OffDeviceStateChanged(callback: Optional<(deviceState: DeviceState) => void>): void;

enum AVSessionErrorCode : i32 {
  ERR_CODE_SERVICE_EXCEPTION = 6600101,
  ERR_CODE_SESSION_NOT_EXIST = 6600102,
  ERR_CODE_CONTROLLER_NOT_EXIST = 6600103,
  ERR_CODE_REMOTE_CONNECTION_ERR = 6600104,
  ERR_CODE_COMMAND_INVALID = 6600105,
  ERR_CODE_SESSION_INACTIVE = 6600106,
  ERR_CODE_MESSAGE_OVERLOAD = 6600107,
  ERR_CODE_DEVICE_CONNECTION_FAILED = 6600108,
  ERR_CODE_REMOTE_CONNECTION_NOT_EXIST = 6600109,
  ERR_CODE_DESKTOP_LYRIC_NOT_ENABLED = 6600110,
  ERR_CODE_DESKTOP_LYRIC_NOT_SUPPORTED = 6600111,
  ERR_CODE_CAST_CONTROL_UNSPECIFIED = 6611000,
  ERR_CODE_CAST_CONTROL_REMOTE_ERROR = 6611001,
  ERR_CODE_CAST_CONTROL_BEHIND_LIVE_WINDOW = 6611002,
  ERR_CODE_CAST_CONTROL_TIMEOUT = 6611003,
  ERR_CODE_CAST_CONTROL_RUNTIME_CHECK_FAILED = 6611004,
  ERR_CODE_CAST_CONTROL_PLAYER_NOT_WORKING = 6611100,
  ERR_CODE_CAST_CONTROL_SEEK_MODE_UNSUPPORTED = 6611101,
  ERR_CODE_CAST_CONTROL_ILLEGAL_SEEK_TARGET = 6611102,
  ERR_CODE_CAST_CONTROL_PLAY_MODE_UNSUPPORTED = 6611103,
  ERR_CODE_CAST_CONTROL_PLAY_SPEED_UNSUPPORTED = 6611104,
  ERR_CODE_CAST_CONTROL_DEVICE_MISSING = 6611105,
  ERR_CODE_CAST_CONTROL_INVALID_PARAM = 6611106,
  ERR_CODE_CAST_CONTROL_NO_MEMORY = 6611107,
  ERR_CODE_CAST_CONTROL_OPERATION_NOT_ALLOWED = 6611108,
  ERR_CODE_CAST_CONTROL_IO_UNSPECIFIED = 6612000,
  ERR_CODE_CAST_CONTROL_IO_NETWORK_CONNECTION_FAILED = 6612001,
  ERR_CODE_CAST_CONTROL_IO_NETWORK_CONNECTION_TIMEOUT = 6612002,
  ERR_CODE_CAST_CONTROL_IO_INVALID_HTTP_CONTENT_TYPE = 6612003,
  ERR_CODE_CAST_CONTROL_IO_BAD_HTTP_STATUS = 6612004,
  ERR_CODE_CAST_CONTROL_IO_FILE_NOT_FOUND = 6612005,
  ERR_CODE_CAST_CONTROL_IO_NO_PERMISSION = 6612006,
  ERR_CODE_CAST_CONTROL_IO_CLEARTEXT_NOT_PERMITTED = 6612007,
  ERR_CODE_CAST_CONTROL_IO_READ_POSITION_OUT_OF_RANGE = 6612008,
  ERR_CODE_CAST_CONTROL_IO_NO_CONTENTS = 6612100,
  ERR_CODE_CAST_CONTROL_IO_READ_ERROR = 6612101,
  ERR_CODE_CAST_CONTROL_IO_CONTENT_BUSY = 6612102,
  ERR_CODE_CAST_CONTROL_IO_CONTENT_EXPIRED = 6612103,
  ERR_CODE_CAST_CONTROL_IO_USE_FORBIDDEN = 6612104,
  ERR_CODE_CAST_CONTROL_IO_NOT_VERIFIED = 6612105,
  ERR_CODE_CAST_CONTROL_IO_EXHAUSTED_ALLOWED_USES = 6612106,
  ERR_CODE_CAST_CONTROL_IO_NETWORK_PACKET_SENDING_FAILED = 6612107,
  ERR_CODE_CAST_CONTROL_PARSING_UNSPECIFIED = 6613000,
  ERR_CODE_CAST_CONTROL_PARSING_CONTAINER_MALFORMED = 6613001,
  ERR_CODE_CAST_CONTROL_PARSING_MANIFEST_MALFORMED = 6613002,
  ERR_CODE_CAST_CONTROL_PARSING_CONTAINER_UNSUPPORTED = 6613003,
  ERR_CODE_CAST_CONTROL_PARSING_MANIFEST_UNSUPPORTED = 6613004,
  ERR_CODE_CAST_CONTROL_DECODING_UNSPECIFIED = 6614000,
  ERR_CODE_CAST_CONTROL_DECODING_INIT_FAILED = 6614001,
  ERR_CODE_CAST_CONTROL_DECODING_QUERY_FAILED = 6614002,
  ERR_CODE_CAST_CONTROL_DECODING_FAILED = 6614003,
  ERR_CODE_CAST_CONTROL_DECODING_FORMAT_EXCEEDS_CAPABILITIES = 6614004,
  ERR_CODE_CAST_CONTROL_DECODING_FORMAT_UNSUPPORTED = 6614005,
  ERR_CODE_CAST_CONTROL_AUDIO_RENDERER_UNSPECIFIED = 6615000,
  ERR_CODE_CAST_CONTROL_AUDIO_RENDERER_INIT_FAILED = 6615001,
  ERR_CODE_CAST_CONTROL_AUDIO_RENDERER_WRITE_FAILED = 6615002,
  ERR_CODE_CAST_CONTROL_DRM_UNSPECIFIED = 6616000,
  ERR_CODE_CAST_CONTROL_DRM_SCHEME_UNSUPPORTED = 6616001,
  ERR_CODE_CAST_CONTROL_DRM_PROVISIONING_FAILED = 6616002,
  ERR_CODE_CAST_CONTROL_DRM_CONTENT_ERROR = 6616003,
  ERR_CODE_CAST_CONTROL_DRM_LICENSE_ACQUISITION_FAILED = 6616004,
  ERR_CODE_CAST_CONTROL_DRM_DISALLOWED_OPERATION = 6616005,
  ERR_CODE_CAST_CONTROL_DRM_SYSTEM_ERROR = 6616006,
  ERR_CODE_CAST_CONTROL_DRM_DEVICE_REVOKED = 6616007,
  ERR_CODE_CAST_CONTROL_DRM_LICENSE_EXPIRED = 6616008,
  ERR_CODE_CAST_CONTROL_DRM_PROVIDE_KEY_RESPONSE_ERROR = 6616100,
}

enum CallerType : String {
  TYPE_CAST = "cast",
  TYPE_BLUETOOTH = "bluetooth",
  TYPE_NEARLINK = "nearlink",
  TYPE_APP = "app",
}

enum SessionCategory : i32 {
  CATEGORY_ACTIVE = 1,
  CATEGORY_NOT_ACTIVE = 2,
  CATEGORY_ALL = 3,
}

struct MenuPosition {
  x: i32;
  y: i32;
  width: i32;
  height: i32;
}

struct CommandInfo {
  callerBundleName: Optional<String>;
  callerModuleName: Optional<String>;
  callerDeviceId: Optional<String>;
  callerType: Optional<CallerType>;
}